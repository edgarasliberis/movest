\documentclass[12pt,british,twoside,notitlepage,usenames,dvipsnames,hypens,final]{report}
%% Page setup
\usepackage[a4paper, twoside]{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=2.5cm,rmargin=2.5cm,headheight=3cm,headsep=0.5cm,footskip=1.5cm}
\usepackage[unicode=true,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=1,
 breaklinks=false,pdfborder={0 0 0},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{pdftitle={Video Steganography using Motion Vectors -- CST Part II dissertation}, pdfauthor={E Liberis}}

\addtolength{\oddsidemargin}{6mm}
\addtolength{\evensidemargin}{-8mm}

\raggedbottom
\sloppy
\clubpenalty1000%
\widowpenalty1000%

%% Font and text flow setup
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}
\usepackage{afterpage}

\usepackage{polyglossia}
\setdefaultlanguage[variant=british]{english}

\usepackage{sectsty}
\allsectionsfont{\sffamily}

\usepackage{fontspec}
\setmainfont[Mapping=tex-text, Ligatures=TeX]{TeX Gyre Pagella}
\setsansfont[Mapping=tex-text, LetterSpace=1]{Gillius ADF}
\setmonofont[Mapping=tex-text]{Latin Modern Mono}

\usepackage{setspace}
\setstretch{1.1}

\setlength{\parskip}{0.5\baselineskip}
\setlength{\parindent}{0pt}

\usepackage{pifont}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{pstricks-add}
\usepackage{subcaption}
\usepackage[section]{algorithm}
\usepackage{algpseudocode}

%% List setup
\renewcommand\thesubsection{\arabic{subsection}.}
\usepackage{enumitem}
\setlist{nolistsep}
\setitemize{itemsep=2pt,topsep=0pt,parsep=5pt,partopsep=0pt}

%% Misc appearance things
\usepackage{pdfpages}
\newtheorem{definition}{Definition}
\numberwithin{equation}{section}
\numberwithin{figure}{section}
\usepackage{multicol}
\usepackage{alltt}
\let\oldalltt\alltt
\renewenvironment{alltt}{\vspace{-0.6\baselineskip}\begin{oldalltt}}{\end{oldalltt}\vspace{-0.1\baselineskip}}

\usepackage{titlesec}
\titlespacing\section{0pt}{4pt plus 0.5pt minus 0pt}{0pt plus 0.5pt minus 0.5pt}
\titlespacing\subsection{0pt}{5pt plus 4pt minus 2pt}{0.5pt plus 0.5pt minus 0.5pt}
\titlespacing\subsubsection{0pt}{5pt plus 4pt minus 2pt}{0.5pt plus 0.5pt minus 0.5pt}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}
\titleformat{\chapter}[hang]{\Huge\sf\bfseries}{\scalebox{2}{\circled{\thechapter}}}{1cm}{\Huge\bfseries}

\usepackage{epigraph}
\setlength{\epigraphrule}{0pt}

\usepackage{titletoc}
\titlecontents{chapter}% <section-type>
  [0pt]% <left>
  {\addvspace{1em}}% <above-code>
  {\sf\bfseries\chaptername\ \thecontentslabel:\quad}% <numbered-entry-format>
  {\sf\bfseries\thecontentslabel}% <numberless-entry-format>
  {\bfseries\hfill\contentspage}% <filler-page-format>
  []

%% Some useful macros
\newcommand{\arr}{\textrightarrow\ }
\newcommand{\textsb}[1]{\textsf{\textbf{#1}}}
\newcommand{\textsbc}[1]{\sffamily \textsc{\textbf{#1}}}
\usepackage{lipsum}
\usepackage{tikz}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

%% Title Page
\pagestyle{empty}

\hfill{\LARGE Edgaras Liberis}

\vspace*{60mm}
\begin{center}
\Huge
{\bf Video Steganography \\ using Motion Vectors} \\
\vspace*{10mm}
{ \sc \LARGE
Computer Science Tripos, Part II \\
Homerton College \\
}
\vspace*{10mm}
\the\year 
\end{center}

\cleardoublepage

%% Proforma
\pagenumbering{arabic}
\setcounter{page}{3}
\pagestyle{plain}

{\section*{\Huge Proforma}}

{\large
\begin{tabular}{ll}
Name:               & \bf Edgaras Liberis                          \\
College:            & \bf Homerton College                         \\
Project Title:      & \bf Video Steganography using Motion Vectors \\
Examination:        & \bf Computer Science Tripos Part II, 2016    \\
Word Count:         & \bf XXXX\footnotemark[1]                     \\
Project Originator: & Edgaras Liberis                              \\
Supervisor:         & Daniel Thomas                                \\ 
\end{tabular}
}
\footnotetext[1]{This word count was computed
by {\tt detex diss.tex | tr -cd '0-9A-Za-z $\tt\backslash$n' | wc -w}
}
\stepcounter{footnote}
\vspace{0.5cm}

\section*{Original Aims of the Project}

The aim of this project is to implement and evaluate existing steganographic methods applied to motion vectors. To achieve this, an end-user tool should be developed to offer several steganographic methods. The algorithms will be evaluated based on criteria such as embedding capacity, speed, and detectability. A suite of steganalysis tools will be created.   

\section*{Work Completed}

Applications for embedding and extracting data from motion vectors were developed, featuring several popular LSB steganography algorithms. Matlab functions and scripts for steganalysis were created to extract and analyse motion vectors, offering classic and motion-vector-specific attacks against embedding schemes. Algorithms were compared against each other evaluating detectability, capacity and other aspects. Humans were used to evaluate detectability.

\section*{Special Difficulties}

None.

\cleardoublepage

%% Declaration of Originality
\section*{Declaration of Originality}
I, Edgaras Liberis of Homerton College, being a candidate for Part II of the Computer Science Tripos, hereby declare that this dissertation and the work described in it are my own work, unaided except as may be specified below, and that the dissertation does not contain material that has already been used to any substantial extent for a comparable purpose.

\bigskip
\leftline{\bf Signed }

\medskip
\leftline{\bf Date}

\cleardoublepage
\tableofcontents
%% Chapters
\renewcommand{\thesection}{\arabic{chapter}.\arabic{section}}
\renewcommand{\thesubsection}{\arabic{chapter}.\arabic{section}.\arabic{subsection}}
\setcounter{chapter}{0}

% Introduction
\cleardoublepage
\chapter{Introduction}
\pagestyle{headings}

\emph{Steganography} is the art of concealing information within ostensibly innocent carrier data \cite[p.~3]{fridrich}, usually with the intention of creating a covert channel. Its applications include bypassing government censorship, avoiding law enforcement or military intelligence, and other situations in which detection of the communication may be harmful to the communicating parties (such as by revealing their location~\cite{infohiding-survey}). 
 
\section{Motivation}
\label{motivation}

In recent years, steganography research has explored the use of digital formats as the carrier data for hidden messages. Often, redundancy in data formats provides opportunity for concealing a payload \cite[p.~2]{fridrich}. Since multimedia formats have become so widespread online, their use is now unremarkable and unlikely to raise suspicion.

A sensible approach to digital steganography is to hide data in regions of a file that are highly tolerant to small modifications or noise, such as by slightly changing the colour of a pixel in an image. Since the least significant bit in the binary representation of a value typically corresponds to the highest granularity level, changing it is less likely to be noticed---the key concept behind the so-called \emph{least-significant-bit (LSB) embedding}~\cite{bateman}\label{lsb-steg}. 

Let us consider video steganography. The Moving Picture Experts Group (MPEG) video format encodes a video stream as a sequence of frames. Since encoding every frame independently would be costly, the similarity of successive frames is exploited where possible to store frames as a set of changes from their predecessors. These changes are represented by how much a certain block of pixels has moved (\emph{motion vector, MV}) and how, in addition to this motion, the pixels have changed (\emph{prediction error}). Frames encoded independently are called \emph{intra-frames} or \emph{key frames} (essentially a JPEG image) and those encoded as differences called \emph{inter-frames}~\cite{h264-std}. While both hold potential as carrier data, embedding data into motion vectors will be considered.

To evaluate a steganographic algorithm, we need to determine if its use is detectable by an adversary. The study of methods of detecting steganographic manipulations is called \emph{steganalysis}. Steganalysts use various domain-specific statistical attacks, such as plotting histograms, looking for correlations (or lack thereof) in the data, \emph{etc.} to detect the hidden message.

This project explores hiding data in the motion vectors of \texttt{MPEG} videos by applying LSB embedding to the $x$ or $y$ components of the vector. A tool was developed to offer several high-capacity data embedding algorithms and encryption with a user-provided password. These algorithms were evaluated based on embedding capacity, speed, and detectability (using statistical steganalytic methods implemented in Matlab).

\section{Existing work}

Traditionally, image steganography has received more research attention than video steganography, so early attempts tried to directly use existing image (JPEG) steganography techniques~\cite{bateman, jpegdctcoding}.

Bateman reviews the evolution of LSB-based embedding algorithms~\cite{bateman}. Simple strategies such as changing the intensity of every pixel are destroyed by the lossiness of JPEG compression when the image is recompressed. This can be mitigated by embedding data into something that JPEG stores directly in a compressed file, so later research focused on using the DCT coefficients for this purpose\footnote{
One of the main compression techniques that JPEG uses is \emph{Discrete Cosine Transform (DCT)}, which is similar to the Fourier Transform. A relatively small number of coefficients is enough to reconstruct an image with sufficient quality. Those coefficients are insensitive to small changes, making they are suitable for data embedding.}~\cite{jpegdctcoding}. Other approaches improve on this by preserving statistical properties that ``clean'' images would possess~\cite{bateman, f5} (further discussed in \ref{emb-alg}). Similarly to this project, Williams~\cite{scott-fs} applies these image steganography techniques to videos by considering uncompressed videos as series of JPEG-encoded frames.

Other researchers explored inter-frame steganography using motion vectors. Xu \emph{et al.}~\cite{xu2006steganography} used the phase of an MV ($\tan^{-1}(\frac{y}{x})$) to determine which of the $x$ or $y$ component will carry a single bit of payload data (I discuss this method more in \ref{xu-alg}). Non-LSB algorithms include an interesting approach by Fang \emph{et al.}~\cite{fang2006data}, who proposed to find an alternative motion vector (with minimum prediction error), whose phase will be in a particular quadrant out of 4. This conveys 2 bits of information per MV.

One of the main deliverables of this project is a simple tool for doing MV-based steganography. Popular existing steganography tools, such as MSU StegoVideo\footnote{\url{http://www.compression.ru/video/stego_video/index_en.html}} or OpenPuff\footnote{\url{http://embeddedsw.net/OpenPuff_Steganography_Home.html}} do not implement MV steganography, so they will not be discussed further. The only implementation of MV steganography that I was able to find is James Ridgway's \emph{Steganosaurus}~\cite{steganosaurus}, but its algorithm seems rather limited. It only modifies the first (presumably the top left) motion vector of every frame, severely limiting embedding capacity and increasing the ease of detection (as the location of the modified MV is known).

Meanwhile, steganalysis exploited properties specific to motion vectors to create novel steganalysis methods. A recurrent approach in these methods is developing a system to extract certain statistical features from videos and use them to train a classifier. Xu \emph{et al.}~\cite{xu2013video} proposed to build a set of vector algebra constraints between MVs across several frames for this purpose. Deng \emph{el al.}~\cite{deng2012digital} observes that neighbouring MVs often have the same motion vectors, so an abnormal MV can be spotted. Surprisingly, Cao \emph{et al.}~\cite{cao2012video} argues that simply transcoding\footnote{Unpacking a video into a sequence of images and recompressing it back again.} a video would revert a significant amount of MVs to their original values. This reversion technique is evaluated in \ref{rev-tech}.

\subsection*{Outline of the rest of the document}
\begin{itemize}
\item Chapter 2 (Preparation) discusses relevant theoretical background on steganography, steganalysis and video encoding in more detail, and justifies the use of motion vectors as an embedding space. This is followed by the development plan for project's software deliverables. 
\item Chapter 3 (Implementation) reviews the implementation of the steganography library and video-processing applications. This is followed by an in-depth review of steganalysis methods and embedding algorithms, with some in-line detectability evaluation.
\item Chapter 4 (Evaluation) discusses remaining aspects of detectability evaluation, including the use of automated steganalysis methods. Secondary properties, such as embedding capacity and speed are also covered.
\item Chapter 5 (Conclusions) summarises the work done and presents ideas for potential improvements.
\end{itemize}
 

% Preparation
\cleardoublepage
\chapter{Preparation}

\textit{This chapter presents the theory behind steganography and steganalysis in more detail, covers relevant video encoding principles, and makes the case for using motion vectors to do video steganography. This is followed by a discussion about the project's software deliverables, formal requirements, existing libraries and tools leveraged, risk analysis, workflow and starting point.}

\section{Steganography background}

This project develops a \emph{steganographic system}, so let us review terminology used in the field~\cite{infohiding-survey, bateman}:
\begin{itemize}
\item \emph{Embedded data / payload} --- the message that one wishes to hide.
\item \emph{Carrier data / cover} --- an object (video) that will contain the embedded data.
\item \emph{Stego-object } --- an object (video) that already contains the embedded data.
\item \emph{Stego-key} ---  data that is used to ``control the embedding process and/or to restrict detection and/or recovery of the embedded data to parties who know it"~\cite{infohiding-survey}. This could be a user-provided password which is later used to seed a pseudo-random number generator (PRNG) or derive encryption keys. 
\item \emph{Embedding space} --- a particular type or region of data in a cover that is suitable for carrying the payload, for example DCT coefficients in JPEG.
\item \emph{Embedding capacity} --- the amount of information (in bits) a particular embedding scheme can hide within a certain cover. Typically it also depends on the payload as well, but this condition is relaxed for now.
\end{itemize}

\begin{definition}{Steganographic system~\cite[p.~53]{fridrich}}

Let $\mathcal{C}$ be the set of all cover objects. For a given $x \in C$, let $\mathcal{K}(x)$ denote the set of all stego-keys for $x$, and the set $\mathcal{M}(x)$ denote all messages that can be communicated in x. A steganographic system is then formally defined as a pair of embedding and extracting functions \texttt{Emb} and \texttt{Ext},
\begin{align*}
\texttt{Emb} &: \mathcal{C} \times \mathcal{K} \times \mathcal{M} \rightarrow \mathcal{C} \\
\texttt{Ext} &: \mathcal{C} \times \mathcal{K} \rightarrow \mathcal{M}
\end{align*}
\vspace{-1mm}
such that
\vspace{-1mm}
\begin{align*}
\forall x \in \mathcal{C}, k \in \mathcal{K}(x), m \in \mathcal{M}(x) . ~ \texttt{Ext}(\texttt{Emb}(x, k, m), k) = m
\end{align*}

\end{definition}

In other words, a steganographic system (also referred to as an \emph{embedding scheme / algorithm}) is defined by providing \emph{embedding} (encoding) and \emph{extracting} (decoding) functions which describe how payload's bits should be embedded within (or extracted from) the cover.

A steganographic system aims to protect the payload from being detected by an adversary. Therefore, before discussing system's security properties, one should make reasonable assumptions about adversary's capabilities. Steganography considers three types of adversaries~\cite{craver1998public}:
\begin{itemize}
\item \emph{Passive warden} -- an adversary who can only spy on the communication.
\item \emph{Active warden} -- an adversary who can perform reasonable modifications to the stego-object, such as cropping the edges of an image.
\item \emph{Malicious warden} -- an adversary who can significantly modify the payload or try to impersonate either party.
\end{itemize}
The term "warden" stems from earlier work that considered communicating prisoners, with the warden passing messages between cells~\cite{craver1998public}. This project is only concerned with passive wardens, so stego-videos are not expected to withstand resizing, transcoding, \emph{etc.}

Steganographic systems should avoid relying on so-called `security through obscurity', as it is just a matter of time before an adversary figures out how the system works. Effective systems satisfy \emph{Kerckhoffs' principle}\footnote{Which states that one should assume the system is known to the enemy, so ``security must lie only in the choice of key"~\cite{infohiding-survey}.} and employ a \emph{stego-key} which is assumed to be already shared between all parties. Schemes implemented in the project use it for two purposes:

\label{why-encrypt}
\begin{itemize}
\item Deriving a cryptographic key with which to encrypt the payload. Since encrypted data is indistinguishable from random noise, this makes it harder to detect once embedded in an already-noisy region of the cover.

\item Seeding a PRNG to the same value for all parties. This is useful for schemes that spread the payload over the cover, for instance, by selecting a location for each bit of the payload at random.
\end{itemize}
\section{Steganalysis background}

Steganalysis is the study of detecting messages produced by steganographic systems~\cite[p.~10]{fridrich}. A steganographic system is considered broken if a steganalyst is able to tell whether a given object contains a hidden payload with a probability better than a random guess.

Steganalytic techniques can be manual or automated, and can be further split into two broad categories~\cite{bateman}:
\begin{itemize}
\item \emph{Targeted Steganalysis.} Seeks abnormalities left by a known embedding scheme using visual or statistical attacks specific to it.
\item \emph{Blind Steganalysis.} Assumes nothing about the embedding scheme, instead looking for unusual properties of the given object. 
\end{itemize} 

This project implements both targeted and blind steganalysis methods against motion vector steganography.

\section{Video steganography}

The project uses MPEG video files as covers. The MPEG format should be explored in more detail to see whether the use of motion vectors for data hiding is feasible.

\subsection{Video encoding background}

A video \emph{codec} (en\underline{co}der + \underline{dec}oder) is a program that takes a series of images (video frames) and compresses it into a single video file or vice versa \cite[sec.~3.1]{richardson2004h}. MPEG family of codecs is a popular choice for video compression.

As discussed in \ref{motivation}, an MPEG video stream is represented by a series of interleaved \emph{intra-} and \emph{inter-frames}. Intra-frames are also known as \emph{I-frames} and inter-frames are further classified into \emph{P-frames} or \emph{B-frames}. P- (prediction) frames encode an image by only looking at the predecessor frame, whereas B- (bidirectional) frames consider both predecessor and successor frames [Fig.~\ref{fig:ipb-seq}]~\cite{crowcroft1999internetworking}. To simplify the implementation, from now on I will only consider P-frames, although, in principle, all methods should apply equally well to B-frames.

\begin{figure}[tbh]
\centerline{\includegraphics[width=0.7\textwidth, height=0.7\textheight, keepaspectratio]{img/IPB_images_sequence.png}}
\caption{An example of interleaved I-, B- and P-frames representing a video stream. The encoder may choose a different sequence of frame types. Reproduced from~\cite{interframe-wiki}.}
\label{fig:ipb-seq}
\end{figure}

A frame which will be encoded as a P-frame is partitioned into blocks of size 16-by-16 pixels\footnote{H.264 allows higher granularity for fine details by allowing some blocks to be 8x8, 8x16 or 16x8.}. These blocks are called \emph{macroblocks}, and for each macroblock the encoder searches for its most similar match in a predecessor frame (within a bounded search window) \cite[p.~256]{richardson2004h}. The difference in pixels between the matched block and the original is called the \emph{prediction error}, and the displacement between the two is called the \emph{motion vector} [Fig.~\ref{fig:mb-search}]. For simplicity, we say that a block of pixels has moved since the predecessor frame by the amount specified by its motion vector and, in addition to motion, pixels themselves have changed according to the prediction error.

\begin{figure}[tbh]
\centerline{\includegraphics[width=0.7\textwidth,height=0.7\textheight,keepaspectratio]
{img/macroblock-diagram.png}}
\caption{An illustration of a macroblock search from the current (target) frame to the predecessor (reference) frame. A macroblock is encoded using its prediction error and  motion vector.}
\label{fig:mb-search}
\end{figure} 

\subsection{Motion vectors as embedding space}
\label{mv-emb-space}

Computing motion vectors is a tradeoff between accuracy and computation time, tuned using the search window size. As such, codecs typically use an approximation instead of a globally optimal MV, resulting in a non-minimal prediction error \cite[p.~257]{richardson2004h}. While the MVs are encoded losslessly, the accuracy error allows minor changes to go unnoticed, making them suitable for LSB steganography (see \ref{lsb-steg}).

To estimate the embedding capacity, we generalise how all implemented embedding schemes should operate on motion vectors. Suppose an embedding scheme processes every motion vector in a grid individually for every frame and has an associated selection function $f$ which provides a number of bits that can be embedded into a particular motion vector. Later on, this function will allow to conveniently define a MV selection criteria for different embedding schemes.

\begin{definition}{Embedding capacity for video}

Let $M$ be an embedding scheme with an associated function $f_M : \mathbb{R}^2 \rightarrow \mathbb{N}$, which calculates how many bits can be embedded into a particular motion vector $\overrightarrow{mv} \in \mathbb{R}^2$. Then for an MPEG-encoded video $V$, the embedding capacity $\mathcal{C}_{V, M}$ is defined as:

$$ \mathcal{C}_{V, M} = \sum_{p \in \text{P-frames}(V)} \: \sum^{H}_{j = 0} \sum^{W}_{i = 0} f_M(\overrightarrow{mv}^p_{i, j})$$

where $W$ and $H$ are width and height of the macroblock grid, P-frames$(V)$ is a set of all P-frames of a video $V$ and $\overrightarrow{mv}^p_{i, j}$ is the MV of a macroblock  in $i$-th row and $j$-th column of the frame $p$.

\end{definition}

To see whether videos could generally hold a non-negligible amount of hidden data, one can estimate $\mathcal{C}_{V, M}$ by taking a product of the number of P-frames, the total number of MVs per frame and the average number of bits embedded per MV. For instance, an average HD video could reasonably have 6--15 P-frames per second\footnote{Depends on how often the encoder decides to use B-frames and I-frames. P-frames are better for video streaming as they do not require the successor frame during decoding.} with 3600 MVs each\footnote{If video's resolution is 1280x720 (HD), 16x16 macroblocks would partition the frame into a grid of size 80x45. This gives 3600 macroblocks in total.}. Assuming only a quarter of each frame would contain embedded data, I estimate the channel's capacity to be 5.4--13 Kbits/s. Since videos contain audio tracks and a higher number of pixels (or DCT coefficients) than images, a video file typically has higher embedding capacity than an audio file or an image.

\section{Requirements analysis}

The project has two main software deliverables:
\begin{itemize}
\item  An application that allows a user to embed secret messages into MPEG video files using a selection of LSB embedding algorithms.
\item A steganalysis suite that implements some general-purpose routines to detect motion vector-based steganography.
\end{itemize}

Below is a list of requirements for both deliverables, prioritised using \emph{MoSCoW} criteria~\cite{softid-notes}.

\subsection{Steganographic application}
\label{req-steg-app}
\begin{itemize}
\item (M) Ability to access motion vectors of an MPEG video file.
\item (M) Ability to reliably embed data within motion vectors.
\item (M) Multiple LSB embedding techniques.
\item (M) User-friendly binaries to perform embedding and extraction.
\item (S) Encryption of the secret message prior to embedding.
\item (S) Integration with an existing video codec.
\end{itemize}

\subsection{Steganalysis suite}
\label{req-steg-suite}
\begin{itemize}
\item (M) Ability to extract and process motion vector data.
\item (M) Multiple steganalysis methods.
\item (M) Documentation on usage and interpretation of the results.
\item (M) Evident effectiveness in detecting implemented embedding techniques.
\item (S) Compatibility with existing scientific computation packages (Matlab or Python-based packages)
\item (S) Usefulness (verbosity, amount of information provided) to the steganalyst.
\end{itemize}

\section{Project workflow}

\subsection{Technical choices}
\label{tech-choices}

The steganographic application requires modifying MPEG video files, which in turn requires parsing the format of a file, modifying motion vector values, and repackaging the data back into a playable video. Developing a codec does not relate to steganography and is potentially error-prone, so I leverage an existing set of codecs---\texttt{FFmpeg}\footnote{\url{https://www.ffmpeg.org/}}---to achieve this. As codecs are typically written in C or C++, it is a natural choice for this task to and makes the integration easier.

Performing encryption prior to embedding requires using a cryptography library. I chose \emph{Crypto++}, a popular C++ cryptography library.

The steganalysis suite was integrated into the Matlab scientific computation package for user's benefit, because it provides useful tools, such as statistical primitives, plotting capabilities and classifiers, without changing the environment. I chose Matlab  because of its widespread use and comprehensive functionality.

\subsection{Risk analysis}
FFmpeg is a complex piece of software, mostly written in a style of C that sacrifices clarity for performance. A potential risk for the project was the difficulty of proper integration with FFmpeg and hence inability to access or reliably modify motion vectors. Complete failure to do so was unlikely, but it could have consumed a significant amount of development time. To mitigate this, some ``catch-up'' time was allocated in the project timetable.  

\subsection{Development choices}
\begin{itemize}
\item \emph{Git} was used for version control, allowing quick roll-back and managing multiple source trees using branches.
\item \emph{Backups} were done by uploading the source tree and other relevant files to Dropbox. The git repository itself was hosted remotely on GitHub.
\item \emph{Testing} was done both manually and using unit tests to verify that software performs as intended. As a good practice, compiler warnings were treated as errors. Unit tests were implemented using Google Test framework and also served as a regression test suite.
\item \emph{Interative (spiral) development model} was used, which allowed continuously adding and testing new embedding schemes and steganalysis methods.
\item Software components have a \emph{modular design}, which enabled better maintainability and testability, and well-defined interfaces allowed changing internal implementation without breaking compatibility with other components.
\end{itemize}

\section{Starting point}
This project uses some cryptography concepts introduced in the Part IB \textit{Security I} course. I have had some C++ knowledge from past programming experience and the \textit{Programming in C and C++} course. 

Prior to submitting the proposal, I have familiarised myself with the general concepts of steganography and LSB embedding though some introductory texts and relevant papers, and briefly looked at H.264 codec format.

During the development of this project I made use of some material covered in the following Part II courses:
\begin{itemize}
\item \textit{Information Theory} --- channel capacity, error correcting codes;
\item \textit{\LaTeX~and Matlab} --- typesetting and basics of Matlab;
\item \textit{Artificial Intelligence II} --- classifier evaluation.
\end{itemize}

\bigskip\bigskip
\subsubsection*{Summary}
This chapter summarised relevant theoretical and practical background necessary to start the implementation. The next chapter will cover the design and features of the system, implemented steganographic algorithms and steganalysis methods, together with some in-line evaluation.

% Implementation
\cleardoublepage
\chapter{Implementation}

\textit{This chapter covers the implementation details for the steganographic application and the steganalysis suite. I discuss the operation of the encoder and decoder applications, integration with the codec, structure and implementation of the embedding algorithms, and the details of some steganalytic attacks. Some in-line evaluation of algorithms is presented to motivate the design improvements.}

\section{Steganographic application}

\subsection{Integration with FFmpeg}
\label{integrate-ffmpeg}

The project requires modifying MPEG files, so, as discussed in section \ref{tech-choices}, FFmpeg is used to provide this functionality. Finding a suitable way to integrate with FFmpeg was one of the biggest challenges that the project faced early on. FFmpeg is split into several libraries, each with a dedicated purpose such as stream multiplexing, resampling, or supporting I/O devices. The most suitable library for my purposes with was \texttt{libavcodec} which implements various audio and video codecs. Due to its popularity, I decided to focus on H.264, which FFmpeg offloads to a separate library: \texttt{libx264}. While \texttt{libavcodec} exposes an API for runing the codecs it provides, it provides no way to manipulate motion vectors. As such, \texttt{libavcodec} needed modifying to either introduce an additional API or to have it call my steganographic routines itself.

Initially, I looked for a point in the macroblock search phase where motion vectors would already be available, but the prediction error would not have been computed yet. This would allow modification of MVs without any visual footprint because prediction error would have brought the pixels to their required values regardless of the motion vector's value. However, since both FFmpeg and \texttt{libx264} exhibit complex data flow, and are written in optimised C, analysis proved more difficult than anticipated, producing a 4 week delay compared to the original timeline. To address this, the plan was changed to:
\begin{itemize}
\item Use a codec contained within \texttt{libavcodec}, obviating the need to touch \texttt{libx264}. I chose MPEG-4 Part 2 (\texttt{xvid}), H.264's popular predecessor.
\item Focus on modifying motion vectors, because it is essential to the project. The macroblock search is deep within the encoding pipeline, making it less amenable to modification. Instead, I chose to modify motion vectors before they are written to the output file.
\end{itemize}

However, this leaves prediction errors unmodified. To evaluate how much this affects the system, an experiment on human subjects was conducted to determine if this visual footprint is noticeable. This is further discussed in section \ref{exp-human-subj}.

\subsection{Steganography library}

\subsubsection{C API}

To achieve a modular design and decouple from FFmpeg, the implemented steganographic algorithms were separated into a standalone library \texttt{movestlib}\footnote{\texttt{movest} (\underline{mo}tion \underline{ve}ctor \underline {st}eganography) is the codename for this project.}. The library is implemented in C++, exposing a C API for integration with FFmpeg, and encoder and decoder applications (Figure \ref{fig:movest-c-api}). The exact operation of these methods is described in section \ref{enc-dec-bin} using these applications as examples.

\begin{figure}[tbh]
\centering
%\resizebox{0.9\textwidth}{!}{\input{img/movest-c-api.tex}}
\includegraphics[width=0.9\textwidth]{img/movest_c_api.png}
\caption{UML diagram of the C API provided by \texttt{movestlib}. (Some method parameters omitted for brevity.)}
\label{fig:movest-c-api}
\end{figure}

A singleton instance of an embedding algorithm is kept active after initialisation. FFmpeg feeds motion vector data into the algorithm by calling C API methods \texttt{movest\_encode/decode}.  

\begin{figure}[!htbp]
\centering
%\resizebox{\textwidth}{!}{\input{img/movest-alg-class-diag.tex}}
\includegraphics[width=\textwidth]{img/movest_alg_class_diag.png}
\caption{UML diagram of embedding algorithms implemented in \texttt{movestlib}. (Some unimportant fields, methods and method parameters omitted for brevity.)}
\label{fig:movest_alg_class_diag}
\end{figure}

\subsubsection{Class hierarchy}

To encourage modularity and code reuse, the embedding algorithms were implemented as OOP classes. The class hierarchy is presented in Figure \ref{fig:movest_alg_class_diag}. \texttt{Algorithm} is the base class for all embedding algorithms, containing common functionality such as initialising the payload file or operating on every motion vector of a suitable type in turn. Most algorithms, however, extend \texttt{HideSeek} or its subclasses to benefit from the following more specific functionality:

\begin{itemize}
\item Operating on a per-component basis. Motion vectors are stored as $x$ and $y$ components and many algorithms treat them independently (\texttt{RandomisedHideSeek, OutGuess1}).
\item Sequential data fetching and stopping criteria. Some algorithms read and embed payload bits sequentially and require knowledge of when to stop embedding (\texttt{XuAlg, MVSteg}).
\item Both of above (\texttt{MSteg, F3, F4}).
\end{itemize}

\subsubsection{Encryption}
\label{encryption}
Encrypting the payload hides the structure of the data by making it indistinguishable from random noise, making it hard to detect in already-noisy regions, as well as causing it to remain unreadable by an adversary even if steganography was broken. \texttt{movestlib} achieves this by implementing a file-like object for accessing the payload, and encrypting or decrypting the data on the fly (\texttt{MOVEST\_ENCRYPTION} flag). Encryption is done using AES in counter (CTR) mode with a 256-bit key. The key and the initialisation vector are derived from the user-supplied password by performing key stretching using the industry-standard PBKDF2-HMAC-SHA1 key derivation function. Since implementing cryptographic primitives yourself is potentially error-prone, the Crypto++ library was used to provide them. 

\subsection{Encoder and decoder applications}
\label{enc-dec-bin}
The project provides video-processing applications for embedding and recovering the payload from a video file. The two are largely based on FFmpeg examples for transcoding (\texttt{transcoding.c}) and motion vector extraction (\texttt{extract\_mvs.c}), which already contain the code to trigger code paths in FFmpeg that I have modified. Figure \ref{fig:encoder-help} provides an example of options available for the embedding application (encoder).

Before letting FFmpeg process the video, applications parse user input to initialise \texttt{movestlib} with required data, such as the embedding algorithm (\texttt{movest\_init\_algorithm}), the payload file path, and the encryption password (\texttt{movest\_init\_encoder/decoder}). FFmpeg treats sequences of frames as streams, meaning frames are written to the output file sequentially and it is not possible to access a previous or future frame during the embedding process. Algorithms that require estimating certain parameters, such as the embedding capacity of a video, have to make all these decisions in advance. To facilitate this, the encoder performs a dry run (\texttt{MOVEST\_DUMMY\_PASS} flag) which does not modify the motions vectors, in order to collect useful data.

\begin{figure}[tbh]
\vspace{1em}
\centering
\begin{minipage}{0.9\textwidth}
\begingroup
    \fontsize{10pt}{12pt}\selectfont
\begin{alltt}
MOVEST Encoder, (c) 2016
Usage: movest_enc -a <algorithm> -d <data_file> [--encrypt, -p <password>]
<input_video> <output_video>

Command line arguments:
 --encrypt        Perform encryption of the data prior to embedding
 -a/--algorithm   An embedding algorithm to use
 -d/--data        Path to a file, containing the payload
 -p/--password    An encryption password to use
 -h/--help        Print this help message

Available algorithm options:
 'dummypass' (does not embed data)
 'hidenseek' 'msteg' 'f3' 'f4'
 'mvsteg' 'xualg'
 'rand-hidenseek' 'outguess1'
\end{alltt}
\endgroup
\end{minipage}
\caption{User help (\texttt{-{}-help}) of the Movest encoder.}
\label{fig:encoder-help}
\end{figure}

\section{Steganalysis techniques}
\label{steg-tech}

The steganalysis techniques for this project were implemented in Matlab, where the large library of pre-existing statistical and data processing routines makes things considerably simpler.

\subsection{Motion vector import}
\label{mv-import}

The decoder application can be configured to use a special algorithm \texttt{DumpMvs} which outputs motion vector components in a simple text format. Matlab can later import this data as 3D matrices (\texttt{loadmvs.m}), where the element at $(i, j, k)$ refers to a macroblock at $i$-th row, $j$-th column of the $k$-th frame. 

The codec allows for some macroblocks to be omitted. These are called ``skip'' macroblocks, to which the Movest decoder assigns a special type during extraction. In this case, for the sake of completeness of the grid, FFmpeg reports the motion vector being $(0, 0)$, but a user can filter out such stray zeros by using type information (\texttt{typedmvs.m}).

\subsection{LSB plane, 2D plotting and aggregation into bytes}

This project implements Least Significant Bit (LSB) steganography, so the suite includes a function (\texttt{lsbplane.m}) to project least significant bits out of every motion vector component value. If the embedding algorithm sets the LSBs of motion vectors to exactly payload bits, LSBs can be immediately subjected to visual analysis to reveal any patterns in the data. This is best illustrated by an example.

\begin{figure}[tbh]
\centerline{\includegraphics{img/unencrypted-enc.eps}}
\caption{Sample output of \texttt{plot2d} over LSB plane. Even-numbered and odd-numbered columns contain LSBs for $x$ and $y$ components respectively.}
\label{fig:unencrypted-enc}
\end{figure}

Figure \ref{fig:unencrypted-enc} shows an example of a 2-valued heatmap (\texttt{plot2d.m}) produced by the suite. The plot shows a clear pattern of embedded data in the first half of the frame. Given that there are repeating columns of 1s every 8 bits, a steganalyst could make an educated guess that the payload is ASCII-encoded and attempt to group bits into bytes to reproduce the text (\texttt{aggregateIntoBytes.m}):

\begin{alltt}
    >> char\footnote{In Matlab, \texttt{char} interprets an integer value as an ASCII-encoded character.}(aggregateIntoBytes(mvs, types))'
    ans = hello world\ldots
\end{alltt}

\subsection{Histogram and $\chi^2$ (Chi-Squared) attack}

The distribution of motion vectors can be visualised using a histogram (\texttt{mvhist.m}). This can be a useful source of information for a steganalyst because peculiarities in the histogram can reveal that motion vectors have been modified. MV histograms typically have a sharp peak at 0 and exponentially decay on both sides. Since these histograms are affected by the direction of motion in the video, decay rates may vary, and we may see additional peaks or plateaus. (Figure \ref{fig:histogram-example}).

\begin{figure}[tbh]
\centerline{\includegraphics[scale=0.75]{img/histogram-example.eps}}
\caption{Sample output of \texttt{mvhist} for the $x$ component of all motion vectors in a video.}
\label{fig:histogram-example}
\end{figure}

Westfeld and Pfitzmann~\cite{westfeld1999attacks} developed a method for attacking image steganography called the \emph{$\chi^2$ attack}, which can also be applied to motion vectors. They hypothesise that, due to the nature of the data, it is unlikely that adjacent bars of the histogram would be of the same height. 

Let us focus on adjacent bars on a histogram which correspond to even-odd pairs of motion vector values which only differ in the LSB (0 and 1, 2 and 3, 4 and 5, \emph{etc.}). Since the encrypted payload will, on average, have the same number of 0 and 1 bits, so will the LSBs of motion vector values. Therefore, values in such an even-odd pair should occur the same number of times. It also follows that the histogram bars for an even-odd pair should be of the same height.

We can now devise a statistical procedure (\texttt{chiSquareAttack.m}) for determining the probability that a given set of motion vectors contains a secret message. We consider even-odd pairs of values of the form $(2k, 2k+1)$. 

Let $X_k$ and $Y_k$ be the number of times values $2k$ and $2k+1$ occur as motion vector values. Consider also the average of these, $Z_k = \frac{X_k + Y_k}{2}$. If the video contains a payload, $X_k$ and $Y_k$ should be almost equal and distributed as $Z_k$. To prevent influence from the noise in data, pairs that have $Z_k < 8$ are considered to be under-represented and are neglected in further analysis (\emph{minimum frequency condition}\footnote{The original paper specifies $Z_k < 2$, but I found that this threshold was too low for motion vector data.}).

We can use the \emph{$\chi^2$ (chi-square) test} to check the hypothesis that there is no significant difference between $X_k$ and $Z_k$ (null hypothesis). The case for $Y_k$ is symmetric and not considered further. The test tells us we can compute the quantity

$$ \chi^2_{n-1} \approx \sum^{n}_{k=0} \frac{(\text{observed}_k - \text{expected}_k)^2}{\text{expected}_k}= \sum^{255}_{k=-255} \frac{(X_k - Z_k)^2}{Z_k} $$ 

from which we can obtain the $p$-value of data supporting the null hypothesis, which authors interpret as the probability that the cover contains the payload:

$$ p = 1 - \frac{1}{2^{\frac{n-1}{2}}\Gamma(\frac{n-1}{2})}\int_0^{\chi^2_{n-1}}t^{\frac{n-1}{2}âˆ’1}e^{-t/2}dt $$  

This method can also estimate the size of the payload. From the expression for $\chi^2_{n-1}$, we see that it is sensitive to small changes: the value stays close to 0 when data contains the payload ($X_k - Z_k \approx 0$) and is big otherwise. We can iteratively build up the histogram and update $\chi^2_{n-1}$ as data for every frame comes in. We know that when the value starts increasing (and $p$-value decreases), the data no longer contains the payload, so we can put a bound on the payload size. 

\subsection{Reversion technique}
\label{rev-tech-theory}
Cao \emph{et al.}~\cite{cao2012video} proved that decoding then re-encoding (transcoding) a video tends to remove the changes caused by embedding the payload. That is, motion vectors tend to revert to their original values. So, if a video does not contain a payload, we expect differences between respective motion vectors of the original and transcoded video to be near zero.

\begin{wrapfigure}[13]{R}{6cm}
\vspace{-15pt}
\includegraphics[width=5.5cm]{img/movest_reversion_sketch.png}
\caption{Partitioning stego and non-stego videos.}
\label{fig:movest-reversion-sketch}
\end{wrapfigure}

\emph{Sum of absolute differences (SAD)} is used to compute the difference between respective components of motion vectors:

$$ \Delta \overrightarrow{mv^p_{ij}} = |(\overrightarrow{o^p_{ij}})_x - (\overrightarrow{t^p_{ij}})_x| +  |(\overrightarrow{o^p_{ij}})_y - (\overrightarrow{t^p_{ij}})_y|$$

where $\overrightarrow{o^p_{ij}}$ and $\overrightarrow{t^p_{ij}}$ are motion vectors of the original and transcoded video. To determine how common small and large differences are in a video, the algorithm computes a normalised vector of frequencies for every value of $\Delta\overrightarrow{mv^p_{ij}}$. The $k$-th element of the vector gives the proportion of $\Delta\overrightarrow{mv^p_{ij}} = k$ occurring among all SADs.

The reversion hypothesis suggests the following approach for distinguishing between a stego and non-stego video, summarised in Figure \ref{fig:movest-reversion-sketch}:
\begin{itemize}
\item Stego videos will have a lower frequency of small differences ($\Delta\overrightarrow{mv^p_{ij}} < 2$), but a higher frequency of larger differences ($\Delta\overrightarrow{mv^p_{ij}} \geq 2$).
\item Non-stego videos will have a higher frequency of small differences and a lower frequency of larger differences.
\end{itemize}
A classifier can be built to attempt to differentiate between these two classes of video. I decided to use a Support Vector Machine (SVM) with a linear kernel (as Figure \ref{fig:movest-reversion-sketch} suggests), trained using Matlab's \texttt{fitcsvm} routine. Evaluation of this method is presented in section \ref{rev-tech}.

\section{Embedding algorithms}
\label{emb-alg}

This section presents the 8 LSB steganography algorithms implemented by this project.

\subsection{Hide \& Seek}

\emph{Hide \& Seek}~\cite{bateman} is the algorithm which was used as an example in the previous section. The algorithm embeds payload bits into both $x$ and $y$ components of each motion vector by setting their LSB to that of the payload. This achieves the optimal capacity for this type of embedding of 2 bits per macroblock, but is susceptible to all the attacks described in the previous section. 

\begin{figure}[tbh]
\centerline{
\begin{subfigure}[t]{0.4\textwidth}
\includegraphics[scale=0.8]{img/pre-lsb-embedding.eps}
\end{subfigure}
~
\begin{subfigure}[t]{0.4\textwidth}
\includegraphics[scale=0.8]{img/post-lsb-embedding.eps}
\end{subfigure}
}
\caption{An example of a frame prior to embedding (left) and after embedding at 45\% capacity (right).}
\label{fig:visual-analysis-example}
\end{figure}

Since data is embedded into all possible macroblocks, visual analysis allows easily spotting it in a non-noisy region. Figure \ref{fig:visual-analysis-example} shows two 2D plots of the same frame: one without the embedding and one with data embedded at about 45\% of capacity. Unusual noise in the first half of the frame exposes the embedding.  

\subsection{MSteg}
\label{msteg}

\emph{MSteg} is my straightforward adaptation of the \emph{JSteg} algorithm~\cite{bateman}, which was initially developed for embedding into JPEG DCT coefficients. The algorithm operates in the same way as Hide \& Seek, but addresses the visual detection problem by not embedding into ``still'' regions, where noise would be easily detectable. From the implementation perspective, it avoids embedding bits into 0-valued $x$ and $y$ components. Components with value 1 are also avoided, since embedding bit 0 would turn them into zeros, making decoding ambiguous.

Figure \ref{fig:msteg-visual} shows that MSteg performs better when subjected to visual analysis. However, we would still expect values in an even-odd pair occur at the same frequency, as described earlier. The histogram in Figure \ref{fig:msteg-hist} confirms this and therefore the $\chi^2$ attack is successful at detecting the embedding (Figure \ref{fig:chisq-attack}).

\begin{figure}[tbh]
\centering
\begin{minipage}[t]{.4\textwidth}
  \centering
  \includegraphics[scale=0.8]{img/msteg-visual.eps}
  \caption{LSB plane of the frame subjected to MSteg embedding.}
  \label{fig:msteg-visual}
\end{minipage}%
\quad\quad
\begin{minipage}[t]{.45\textwidth}
  \centering
  \includegraphics[scale=0.84]{img/chisq-attack.eps}
  \caption{An example of probability of embedding computed by the $\chi^2$ attack when embedding was done at 58\% of capacity.}
  \label{fig:chisq-attack}
\end{minipage}
\end{figure}

\begin{figure}[tbh]
\centering
\resizebox{0.6\textwidth}{!}{\input{img/msteg-hist.tex}}
\caption{Part of a histogram of video's motion vectors  after MSteg embedding. Colour cues added to highlight even-odd pairs.}
\label{fig:msteg-hist}
\end{figure}

\subsection{F3}

Another algorithm adapted from image steganography is \emph{F3}~\cite{f5}. F3 improves on previous approaches by decrementing the absolute value of an MV component if its LSB doesn't match the payload bit, breaking the even-odd correspondence exploited by the $\chi^2$ attack. Similarly to MSteg, 0-valued components are ignored by the encoder and decoder. F3's embedding procedure is summarised in Algorithm \ref{alg:f3-embed}. 

\begin{algorithm}[!htp]
\caption{Embedding procedure for \emph{F3}.}
\label{alg:f3-embed}
\begin{algorithmic}
\Procedure {F3-Embed}{$mv_C$, $payload_i$}
\If {$mv_C = 0$}
    \Return {false}
\Else
    \If {$\textit{LSB}(mv_C) \neq payload_i$}
    	\Comment {Decrease the absolute value of $mv_C$}
        \If {$mv_C$ > 0}
        	\State $mv_C \gets mv_C - 1$
        \Else
        \State $mv_C \gets mv_C + 1$
        \EndIf
    \EndIf
    
    \State \Return $mv_C \neq 0$
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

Procedure \textsc{F3-Embed} operates on both $x$ and $y$ components ($mv_C$) of each motion vector in turn and reports whether embedding has been successful, \emph{i.e.} $mv_C$ is a non-zero value. If so, the decoder will be able to use it, and if $mv_C$ was or has become zero, the same bit is re-embedded into a subsequent component. The extraction procedure simply reads the LSBs to reconstruct the data.

\begin{wrapfigure}[13]{R}{6cm}
\vspace{-15pt}
\centering
\includegraphics[width=5.5cm]{img/f3-hist.eps}
\caption{Part of a histogram of motion vectors with F3 embedding. Note the unusually higher peaks corresponding to even numbers.}
\label{fig:f3-hist}
\end{wrapfigure}

This embedding strategy leads to an interesting effect called \emph{shrinkage}. Whenever we try to embed a zero bit (\emph{steganographic zero}) into $mv_C = -1$ or $mv_C = 1$, the value of $mv_C$ will become 0, so the zero bit will have to be re-embedded again, meaning that F3 will embed more steganographic zeroes than ones. 

This is the main weakness of the algorithm. A typical encrypted payload has the same number of steganographic zeroes and ones, but since F3 embeds more zeros, values with LSB 0 will be more common (Figure \ref{fig:f3-hist}). 

\subsection{F4}
\label{f4}

F4~\cite{f5} eliminates the weakness of F3 by using a different strategy for embedding into negative values of $mv_C$. Like F3, $mv_C$ is changed (if required) by decrementing its absolute value. When $mv_C$ is positive, the algorithm ensures its LSB matches that of the payload (just like F3), but when $mv_C$ is negative, the algorithm ensures its LSB \emph{does not} match that of the payload. This mapping is visualised in Figure \ref{fig:f4-mapping} and the pseudocode is listed in Algorithm \ref{alg:f4-embed}.

\begin{algorithm}
\caption{Embedding procedure for \emph{F4}.}
\label{alg:f4-embed}
\begin{algorithmic}
\Procedure {F4-Embed}{$mv_C$, $payload_i$}
\If {$mv_C > 0$ \textbf{and} $\textit{LSB}(mv_C) \neq payload_i$}
    \State $mv_C \gets mv_C - 1$ \Comment {Decrease the absolute value of $mv_C$}
\EndIf
\If {$mv_C < 0$ \textbf{and} $\textit{LSB}(mv_C) = payload_i$}
	\State $mv_C \gets mv_C + 1$ \Comment {Decrease the absolute value of $mv_C$}
\EndIf

\State \Return $mv_C \neq 0$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{figure}[tbh]
\centering
\resizebox{0.75\textwidth}{!}{\input{img/movest-f4-mapping.tex}}
\caption{F4's value mapping depending on the payload bit.}
\label{fig:f4-mapping}
\end{figure}

As we see from Figure \ref{fig:f4-mapping}, shrinkage is no longer exclusively triggered by embedding a steganographic zero. Now it can occur when a steganographic zero is embedded into value 1 or when a steganographic one is embedded into value -1. Assuming both cases occur the same number of times, we can deduce that F4 is not biased towards embedding more zeroes or ones and, therefore, is not vulnerable to the same attack. Detectability of this method using the reversion technique is discussed in section \ref{rev-tech}.

\subsection{Randomised Hide \& Seek}
\label{rand-hidenseek}

All of the previous algorithms share a common property: they embed the payload densely in the beginning of a video file, leaving the rest unmodified. We can achieve better undetectability if we spread a small payload across the entire file, making changes less noticeable. 

\emph{Randomised Hide \& Seek}~\cite{bateman} is a modification of Hide \& Seek algorithm which uses a PRNG to scatter payload bits uniformly across all motion vector components in the video. A simple way to implement this is by choosing an MV component for every payload bit at random, navigating to the chosen frame and embedding data into the chosen component. However, the stream-oriented nature of FFmpeg makes it impossible to switch between frames in this way. To work around this problem, I chose to build a map which assigns every payload bit to a particular (unique) motion vector component ahead of time. This requires knowing the maximum capacity, which is obtained by performing a ``dry run'' beforehand. 

Committing to use a particular motion vector caused an interesting implementation issue. As mentioned in \ref{mv-import}, FFmpeg may choose to omit some macroblocks to save space by marking them as ``skipped'', causing the decoder to infer the motion from neighbouring blocks~\cite{tourapis2004direct}. Changing motion vectors in one P-frame affects which macroblocks are skipped in the following frame. This issue arises when the macroblock pointed to by the mapping gets skipped. I considered three options to mitigate this issue:
\begin{itemize}
\item Further analyse FFmpeg to be able to reliably predict when ``skipping'' happens. This, however, would imply spending a significant amount of time on a side issue.
\item Dynamically rebuild the map as data gets embedded. This is a reasonable solution, but will make the algorithm significantly more complex.
\item Use an error correcting code to reconstruct the missing bits. This saves considerable effort, and adds some robustness against tampering, but also increases the payload size due to inclusion of the correction bits.
\end{itemize}

I went with the third option. Measurements showed that bit errors occur every 400--700 bytes. I chose the widely-used Reed-Solomon~\cite{clarke2002reed} error correcting code, implemented by the \texttt{rscode}\footnote{\url{http://rscode.sourceforge.net/}} library, which operates at a byte-level granularity. My default configuration generously specifies 16 error correction (parity) bytes per 239 bytes of data\footnote{The library limits the size of a data block plus a number of parity bytes to 255.}, but it can be adjusted if required. This arrangement is extremely unlikely\footnote{Assuming that the rate at which errors occur has a normal distribution with mean 550 and variance 150 (in line with the estimate above of 1 error every 400--700 bytes), the probability of a failure is 0.0000065. To account for this, a user can verify that the data can be extracted correctly before transmitting the video.} to fail, as it allows correcting up to any 8 incorrect bytes per 239 bytes of payload data.

Extracting the data using this algorithm requires the receiving party's PRNG to output the same sequence of values as the sender's. This is achieved by seeding both sender's and receiver's PRNGs to the same 128-bit value, derived from the user-specified encryption password (in a same way as the encryption key, see encryption subsection in \ref{encryption}). Due to the way how key derivation functions work, it is impossible to recover the password or the encryption key knowing the seed. The receiving party also has to know a bound for the embedding capacity of a video and the embedded file size, but these can be pre-agreed.

For small payload sizes, the algorithm does not produce equal even-odd pairs in the histogram, making many previous attacks ineffective.

\subsection{Outguess 0.1}
\label{outguess1}

\emph{Outguess 0.1}~\cite{bateman} is essentially the same algorithm as Randomised Hide \& Seek, but it addresses the issue of embedding into ``still'' regions by choosing not to embed into components with value 0 or 1. This is done to avoid the visual analysis attack, which we previously looked at in MSteg design (Section \ref{msteg}). The footprint is further evaluated in the Evaluation chapter, section \ref{eval-var-emb-cap}.

\subsection{Xu's algorithm}
\label{xu-alg}

The project also implements an algorithm that was designed specifically for motion vectors. Xu \emph{et al.} \cite{xu2006steganography} argue that data should be embedded:
\begin{itemize}
\item Only into motion vectors whose length exceeds a certain threshold, as it would introduce less distortion.
\item Into either $x$ or $y$ component depending on the phase of the motion vector $\theta = \arctan(y/x)$:
    \begin{itemize}
    \item If $\theta$ is an acute angle, the horizontal component is modified ($x$).
    \item If $\theta$ is an obtuse angle, the vertical component is modified ($y$).
    \end{itemize}
\item By incrementing the chosen component so that it's LSB matches that of the payload bit.
\item 4 times per GOP\footnote{GOP (Group of Pictures) is a series frames between successive I-frames.} to ``resist video processing''; the starting and ending position of each segment should be recorded in an I-frame.
\end{itemize}

Some of the design decisions made by Xu's algorithm\footnote{The project proposal and progress report refer to this as Zhang's algorithm (2001). Xu's algorithm (2006) is a new iteration of the same technique.} are questionable, so I implemented my own take on this technique (\texttt{MVSteg}), with the following differences:
\begin{itemize}
\item $\theta = 90^{\circ}$ is not a good decision boundary: if a motion vector has a large positive $y$ component, but a small positive $x$ component, modifying the larger one would be less noticeable. However, Xu's algorithm would still choose $x$ component, because $\theta$ is an acute angle. 

Therefore I chose to embed data into the maximal of the two components. If both $x$ and $y$ components are equal, the bit is embedded into both. 

\item Incrementing the chosen component can cause issues if the new value points beyond the edge of the frame. Therefore I chose to decrement the absolute value of the component instead in an F4 fashion.

\item Embedding data four times can expose a pattern that may be detected by a steganalyst. I chose not to implement this approach and embed the data sequentially instead.
\end{itemize}

The two algorithms---the original and my modification---are compared against each other in the Evaluation chapter, section \ref{breaking-xu}.

\section{Testing}

In addition to manual testing, unit tests were written to provide automated regression and integration testing. I used Google Test framework, a mainstream testing solution for C++, to implement small and maintainable tests, which test components of the system independently though their public interfaces.

Tests cover:
\begin{itemize}
\item Encrypted file access --- ensures that data is correctly encrypted and decrypted during reads and writes, when enabled. Tests use the NIST-recommended AES-CTR test vectors\footnote{\url{http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf}, Appendix F, Sect. 5.5}.
\item Embedding algorithms --- ensure algorithms correctly modify and extract data from motion vectors, including typical edge cases for each algorithm.
\item C API --- ensure the whole steganography library can be successfully used though the API. Tests initialise the library, simulate FFmpeg calls and verify the results.
\end{itemize}

\bigskip\bigskip
\subsubsection*{Summary}
This chapter described the design and the implementation details of the steganography and steganalysis software. The next chapter will review the project's achievements, cover remaining aspects of detectability evaluation, and evaluate the embedding capacity and speed properties of the system.

% Evaluation
\cleardoublepage
\chapter{Evaluation}

\textit{This chapter evaluates the software against the initial requirements and presents more steganalytic results. The detectability properties using Xu's algorithm, accuracy of the reversion technique classifier, and effectiveness of varying the embedding capacity are discussed. I also discuss secondary properties of steganographic systems, such as the embedding capacity and speed.
}

\section{Satisfaction of requirements}

Overall, the project was a success. All requirements described in sections \ref{req-steg-app} and \ref{req-steg-suite} were met. The following sections present a quick review of the software, having these requirements in mind.

\subsection{Steganographic application}

The developed steganography software is able to reliably modify and extract motion vector data from MPEG video files. I avoided the need to implement my own video codec by successfully integrating with FFmpeg (see section \ref{integrate-ffmpeg}). The software consists of 3 deliverables: encoder and decoder applications for the user to perform embedding, and a steganography library that can be used separately though an API. The library implements 8 LSB embedding algorithms (see section \ref{emb-alg}). The payload can be encrypted with 256-bit AES--CTR encryption using a user-supplied password. 

\subsection{Steganalysis suite}

The steganalysis suite provides, in MATLAB, facilities for extracting and processing motion vector data, as well as a variety of general attacks for detecting embedded payloads. The following functionality is available:

\begin{multicols}{2}
\begin{itemize}
\item \texttt{loadmvs}, \texttt{typedmvs} --- extraction and filtering of motion vector data;
\item \texttt{lsbplane}, \texttt{plot2d} --- extraction and visualisation of the LSB plane;
\item \texttt{aggregateIntoBytes}, \texttt{seqbytes} --- groups extracted bits into bytes;
\item \texttt{mvhist} --- pre-adjusted histogram to view motion vector data;
\item \texttt{chiSquareAttack} --- compute the embedding probability in the first 1-100\% of the data;
\item \texttt{patternSearch} --- find the most likely locations of the pattern in the data;
\item \texttt{known-attacks/} --- examples attacks on implemented algorithms;
\item \texttt{*svmtraining} --- reversion technique SVM training scripts.
\end{itemize}
\end{multicols}

Implementation details are discussed in section \ref{steg-tech}, and the effectiveness of the attacks is demonstrated in sections \ref{emb-alg} and \ref{rem-detect-eval}. Documentation is provided on how to use the implemented methods and interpret the results. 

\section{Detectability of embedding}
\label{rem-detect-eval}

Perhaps the most important aspect to consider when evaluating a steganographic system is whether the embedding is detectable. Most of the detectability evaluation was done in the previous chapter to justify further algorithm design improvements, also allowing to evaluate the effectiveness of the implemented steganalysis techniques. This section covers remaining steganalysis.

\subsection{Detecting Xu's algorithm's embedding}
\label{breaking-xu}

I discovered a number of apparent flaws in Xu's algorithm (see section \ref{xu-alg}), so I implemented an improved version of the algorithm, which I called \texttt{MVSteg}.

One of improvements is the component selection policy. If the phase of a motion vector is acute, Xu's algorithm will embed its payload into the $x$ component, otherwise it uses the $y$ component, claiming that this results in less disturbance to the motion. However, for instance, in the presence of a motion vector with a large $y$ component and a small $x$ component (yielding an acute phase), a small marginal change in $x$ results in a large relative disturbance to the motion. \texttt{MVSteg} always modifies the largest component of the motion vector, making the relative change less significant.

Figure \ref{fig:xualg-mvsteg-visual} shows an example of some visual artefacts\footnote{Movest does not modify the prediction error, which makes detecting such artefacts easier. However, if it did, it would still be possible to spot this, because the prediction error would have been unusually large.} produced by Xu's algorithm which are not present when using \texttt{MVSteg}.

\begin{figure}[tbh]
\centerline{
\begin{subfigure}[t]{4cm}
\includegraphics[width=4cm]{img/xualg-visual.png}
\end{subfigure}
~
\begin{subfigure}[t]{4cm}
\includegraphics[width=4cm]{img/mvsteg-visual.png}
\end{subfigure}
}
\caption{A frame, showing a sky lantern, containing embedding by Xu's algorithm (left) and \texttt{MVSteg} (right).}
\label{fig:xualg-mvsteg-visual}
\end{figure}

Xu \emph{et al.} also suggest embedding the same chunk of payload data four times at different locations to provide resilience against data corruption. To guide decoding, these locations are stored an I-frame using classical image steganography methods. Unfortunately, this creates a recurring pattern in the LSBs of the used motion vectors, providing an opportunity for attack. I simulated such embedding in the presence some bit corruptions in an attempt to find such repetition. Figure \ref{fig:4xembed} shows a successful result of finding a repeating pattern at four locations, with peaks corresponding to the positions where the pattern closely matches the recovered string\footnote{The sum of squared differences between a pattern and the recovered string is close to zero.}. \texttt{MVSteg} embeds data only once, and hence does not contain exploitable data repetition patterns.

\begin{figure}[tbh]
\centering
\begin{minipage}[t]{.45\textwidth}
  \centering
  \includegraphics[scale=0.9]{img/4xembed.eps}
  \caption{Positions of repeated embedding. Lower bar corresponds to an inexact match.}
  \label{fig:4xembed}
\end{minipage}%
\quad
\begin{minipage}[t]{.45\textwidth}
  \vspace{-5.2em}
  \begingroup
    \fontsize{11pt}{12pt}\selectfont
    \centering
    \begin{alltt}
 {\color{blue}[mpeg4 @ 0x7fc9dc247380]}
            {\color{red}ac-tex damaged at 53 0}
 {\color{blue}[mpeg4 @ 0x7fc9dc247380]}
                   {\color{red}Error at MB: 53}

    \end{alltt}
  \endgroup
  \caption{Macroblock corruption reported by the \texttt{vlc} media player.}
  \label{fig:vlc-corruption}
\end{minipage}
\end{figure}

Xu's algorithm embeds payload bits in motion vectors by incrementing the targeted vector component. For motion vectors near the edge of the frame, such increments can cause the vector to point outside the frame, causing decoding errors and revealing that the video has been tampered with. Figure \ref{fig:vlc-corruption} shows the error that the codec reports when playing such a damaged video. \texttt{MVSteg}'s use of F4's decrementing motion vector scheme avoids this problem, which also makes it resistant to $\chi^2$ and histogram attacks (see sections \ref{steg-tech}, \ref{f4}).

\subsection{Reversion technique}
\label{rev-tech}

The reversion technique (see section \ref{rev-tech-theory}) considers differences between respective motion vectors of the original and the re-encoded (transcoded) video. Evaluating the effectiveness of this technique requires training a linear SVM classifier. In this situation, SVM does not require large datasets to give good results~\cite{cao2012video}, so I have obtained a dataset of 56 freely-available stock videos. Collected videos exhibit various degrees of motion, such as slow cloud movements or chaotic city timelapses. Half of those were chosen to become stego videos, so that the ratio between stego and non-stego videos is 50:50 (balanced dataset).

For each embedding algorithm, the training and evaluation is done as follows:
\begin{itemize}
\item To generate the initial dataset of videos, Movest's encoder is used to embed random data into the 28 stego videos at their full capacity. The remaining 28 non-stego videos are also passed though the encoder without embedding data.
\item To obtain transcoded videos, all previously created videos are passed through the encoder again, letting FFmpeg recompute motion vectors.
\item Motion vectors are extracted from both sets of videos.
\item Motion vector data is imported into Matlab and frequencies of SAD values are computed using the steganalysis suite's \texttt{computeSadFreqs.m} function.
\item Frequency data, together with a labelling whether it came from a stego or a non-stego video, is passed into Matlab's \texttt{fitcsvm} function to train an SVM.
\item Since the dataset is relatively small, the system performs 100 runs of \emph{k-fold cross validation}~\cite{ai2-notes}, with $k = 8$, to estimate the classification accuracy. This is a common technique for evaluating classifiers, provided by Matlab's \texttt{crossval} function.

\end{itemize}

\subsubsection*{8-fold cross validation} 

The data set is randomly partitioned into 8 bins of 7 videos each. For each bin, the other remaining 7 bins are used to train the classifier, which is then applied to the videos in the target bin and the accuracy is computed.\footnote{Using $k = 8$ (close to recommended $k = 10$) allows having a sufficiently large test set for every iteration.}. The average accuracy over all iterations is the result.

Since the resulting accuracy measure is susceptible to unusually favourable random partitioning, the process is repeated 100 times to obtain a 95\% confidence interval for the mean accuracy.

Table \ref{tbl:rev-tech} presents the obtained classification accuracy for each embedding algorithm.

\begin{table}[tbh]
\bgroup
\def\arraystretch{1.3}
\centerline{
\begin{tabular}{|l|c|}
\hline
\textbf{Embedding algorithm} & \textbf{Classification accuracy, 95\% CI} \\
\hline
\textit{Random guess (baseline)} & $50\%$ \\
Hide \& Seek & $100.00\% \pm 0.00\%$ \\ 
MSteg & $92.84\% \pm 0.04\%$ \\ 
F3 & $93.45\% \pm 0.32\%$ \\ 
F4 & $93.25\% \pm 0.16\%$ \\
Xu's algorithm & $63.93\% \pm 0.54\%$ \\
MVSteg & $62.96\% \pm 0.57\%$ \\
\hline
\end{tabular}
}
\egroup
\caption{Reversion technique classifier performance against each sequential embedding algorithm implemented.}
\label{tbl:rev-tech}
\end{table}

The results are surprisingly good, which means this technique is suitable for automated steganalysis. It appears that the accuracy result for each algorithm is similar to the proportion of motion vectors it modifies. 

\subsection{Varying embedding capacity}
\label{eval-var-emb-cap}

Many of the previous attacks, such as the $\chi^2$ attack, exploit the cumulative effect produced when payload bits are embedded close together. Such attacks can be thwarted by spreading the payload uniformly across the cover video.

To evaluate this approach, I tested the $\chi^2$ attack and the reversion technique classifier for MSteg (see \ref{msteg}) against Outguess 1.0\footnote{As discussed in \ref{outguess1}, Outguess 1.0 is the randomised version of MSteg.} algorithm at different embedding capacity settings. A fresh dataset (\emph{i.e.} not used for classifier training) containing 10 videos was used. Table \ref{tbl:detect-outguess} shows how many videos were picked up as stego by both steganalysis methods. 

\begin{table}[tbh]
\bgroup
\def\arraystretch{1.3}
\centerline{
\begin{tabular}{|l|c|c|}
\hline
\textbf{Embedding capacity} & \textbf{RT Classifier} & $\chi^2$ \textbf{attack} \\
\hline
\textit{0\%} & 0/10 & 0/10   \\
10\% & 1/10 & 0/10   \\
20\% & 1/10 & 0/10   \\
30\% & 1/10 & 0/10   \\
40\% & 1/10 & 0/10   \\
50\% & 4/10 & 0/10   \\
60\% & 6/10 & 0/10   \\
70\% & 7/10 & 0/10   \\
80\% & 7/10 & 0/10   \\
90\% & 8/10 & 2/10   \\
\textit{100\%} & 9/10 & 10/10 \\
\hline
\end{tabular}
}
\egroup
\caption{Detectability of Outguess 0.1 embedding at various embedding capacities.}
\label{tbl:detect-outguess}
\end{table}

These data suggest that the reversion technique classifier starts being effective at 50--60\% embedding capacity and the $\chi^2$ attack is only effective from 90\%.

\section{Detectability by Humans (Study)}
\label{exp-human-subj}

\subsection{Study hypothesis}

A study was conducted to test whether human participants are able to distinguish between a stego and a non-stego video when the prediction error is not modified. To test this, I measured how often participants could correctly select the stego video given three ostensibly identical videos. I hypothesise that humans are not able to tell the videos apart (null hypothesis).

\subsection{Experimental procedure}

In each of the 10 trials, the participant was given three ostensibly identical videos under 30 seconds in length, one of which with a hidden payload. They had to choose which video they thought was modified and write its letter into the experiment answer sheet. Using three videos, as opposed to two, eliminates a problematic situation when the participant sees that videos are different, but is unable to tell which one actually contains embedding\footnote{The original experiment description in the project proposal overlooked this issue and stated that 2 videos will be used.}.

To increase chances of successful detection and more closely simulate a real-life steganalysis setting, the following measures were taken:
\begin{itemize}
\item Test subjects were computer-literate. Most were computer science undergraduates.
\item Embedding was done using the Hide \& Seek algorithm, which leaves a significant footprint by modifying every motion vector. The full embedding capacity of every video was used up to embed random data.  
\item Participants had full control over the playback, meaning they could watch videos however they liked: sequentially, side-by-side, repeatedly replay certain parts, inspect file sizes, zoom into certain regions of a video, use either their own or my screen \emph{etc.}
\item The first trial contained an artificially corrupted video (motion vectors were changed more drastically) to give participants an idea of what kind of visual footprint to expect. 
\end{itemize} 

As a precaution, videos did not contain flashing images, were emotionally neutral, and free from distressful, disturbing, offensive or otherwise unsettling images. No personal data about the participants was collected.

\subsection{Results}

To be able to interpret the data, I defined a theoretical model to fit the experiment. Let $n$ be the number of answers that participants gave and $X_i$ ($i \in [1, n]$) denote whether an answer was correct, \emph{i.e.} $X_i = 1$ if a participant correctly identified the stego video in a trial and $0$ otherwise. If the null hypothesis holds, the participants' answers will be indistinguishable from random guesses, meaning the $X_i$ can be modelled as a random variable with $\mathbb{P}(X_i = 1) = 1/3$. That is, the $X_i$'s follow Bernoulli distribution with $p = 1/3$. 

To aggregate, I compute the sum of all $X_i$: $Y = \sum^n_{i=1} X_i$. For sufficiently large $n$, $Y$ follows the Binomial distribution with parameters $(n, p)$~\cite[p.~53]{papoulis2002probability}. Then, by the de Moivre--Laplace theorem, $Y$ can be approximated by a normal distribution with mean $np$ and variance $np(1-p)$~\cite[p.~105]{papoulis2002probability}. This allows us to put 95\% confidence bounds on the value of $Y$~\cite[p.~316--318]{ai2-notes}:
\[ np - 1.96 \sqrt{np(1-p)}  \leq Y \leq  np + 1.96 \sqrt{np(1-p)} \]

If $Y$, obtained from the data set, does not lie in this range, the null hypothesis can be rejected with 95\% confidence.

The data obtained from the experiment is presented in Table \ref{tbl:detect-exp-res}. 

\begin{table}[tbh]
\centering
\bgroup
\def\arraystretch{1.3}
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}
\hline
\textbf{Video \#} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} & \textbf{5} & \textbf{6} & \textbf{7} & \textbf{8} & \textbf{9} & \textbf{10}\\
\hline
\textit{Correct answer} & \textit{B} & \textit{C} & \textit{C} & \textit{A} & \textit{B} & \textit{B} & \textit{A} & \textit{C} & \textit{B} & \textit{A}\\
\hline
Participant \#1  & B & C & C & B & A & C & A & B & A & C \\
Participant \#2  & B & A & B & C & C & B & A & B & A & A \\
Participant \#3  & B & C & B & A & C & A & A & B & A & C \\
Participant \#4  & B & A & A & B & B & C & C & A & B & C \\
Participant \#5  & B & A & C & B & C & A & A & C & B & C \\
Participant \#6  & B & C & C & A & A & B & C & C & C & B \\
Participant \#7  & B & A & A & C & A & C & C & C & C & A \\
Participant \#8  & B & B & A & C & A & A & B & A & C & C \\
Participant \#9  & B & C & B & C & A & C & A & C & C & C \\
Participant \#10 & B & A & A & C & A & C & B & C & A & C \\
Participant \#11 & B & B & B & C & C & B & C & A & C & C \\
Participant \#12 & B & C & A & A & B & B & B & A & B & B \\
\hline
\end{tabular}
\egroup
\caption{Results of the distinguishability of video steganography experiment. Column 1 corresponds to the demo trial with an evidently corrupted video, so it is excluded from the analysis.}
\label{tbl:detect-exp-res}
\end{table}

\textbf{TODO: Comment on potentially small n?}
The data contains 108 answers ($n = \text{\# of participants} \times \text{\# of trials}$), so, according to the formula above, I expect $Y$ to be within the range $36 \pm 5$. The data has 32 correct answers, which is within that range, so it \emph{cannot} be concluded that humans \emph{are} able to identify implemented video steganography. This suggests that the visual footprint produced by not modifying prediction error is not detectable by humans.

\section{Embedding capacity and speed}

A steganographic system also has secondary characteristics worthy of evaluation: embedding capacity and speed. Capacity depends on the number of P-frames, macroblocks (defined by the resolution), and suitable motion vectors (see \ref{mv-emb-space}). The proportion of suitable motion vectors can vary significantly depending on the type of motion in a video, and on what algorithm is used. For instance, \texttt{MVSteg} performs worse on videos with little or slow motion because it only embeds into sufficiently long motion vectors (see \ref{xu-alg}).

To estimate the capacities a user might reasonably expect, I measured embedding capacity per second on a dataset of 53 HD ($1280 \times 720$) videos with varying degrees of motion, averaged over the first 15 seconds. Figure \ref{fig:capacities} presents a box plot of measured capacities for each embedding algorithm. Hide \& Seek achieves an impressive 20~KB/s median embedding capacity; MSteg's, F3's and F4's median result is 6--8~KB/s, and Xu's algorithm and MVSteg have the lowest values of 1~KB/s. 

\begin{figure}[tbh]
\centerline{\includegraphics{img/capacities.eps}}
\caption{Box plot showing possible embedding capacities (KB/s) for every algorithm.}
\label{fig:capacities}
\end{figure}

Video encoding is the most computationally expensive part of the Movest encoder, so the time taken by steganography routines is relatively negligible. I did not observe any significant decrease in the encoding speed, even when using payload encryption. The most noticeable slowdown in the encoder is the initialisation overhead of the Randomised Hide \& Seek algorithm to build the payload bit to MV component mapping (see section \ref{rand-hidenseek}).

\bigskip\bigskip
\subsection*{Summary}
This chapter evaluated the implementation with respect to initial requirements, detectability, capacity, and speed of steganographic systems. The following chapter summarises the undertaken work and suggests future work.

% Conclusions
\cleardoublepage
\chapter{Conclusions}

\section{Accomplishments}

Overall, the project achieved its aim of implementing and evaluating existing LSB steganography methods using motion vectors. Steganographic systems were evaluated based on embedding capacity, speed, and detectability. Detectability was evaluated using implemented steganalysis methods and by carrying out an experiment on human subjects.

A library for performing steganography and related video processing (such as accessing and modifying motion vectors) was developed. The steganalysis suite, implemented using Matlab, provides facilities for extraction and analysis of motion vectors and offers classic and motion-vector-specific attacks against embedding algorithms.

With the benefit of hindsight, I would have implemented the FFmpeg integration prior to starting the project and used it as a starting point. This would have allowed focusing entirely on steganography, giving more time to explore useful extensions.

\section{Future directions}

Many promising avenues for further improvement were not explored due to time constraints:
\begin{itemize}
\item \textit{Non-LSB embedding algorithms.} Fang \emph{et al.}~\cite{fang2006data} propose to restrict motion vector search to the one of 4 quadrants, allowing conveyance of 2 bits of data per MV. This requires a deeper integration with a video codec than I have so far implemented.
\item \textit{Transcoding resilience.} Embedding schemes that withstand transcoding would be useful for things like communication over social media. Services such as YouTube, Facebook and Tumblr transcode user-uploaded videos before presenting them to other users, destroying any payload hidden in motion vectors. Embedding algorithms that make use of error correcting codes or redundant encoding may be better able to resist this.
\item \textit{Explore MV-specific steganalysis further.} In addition to the reversion technique, described in \ref{rev-tech}, the project would benefit from more motion vector-specific steganalysis methods. A few potential candidates were mentioned in the Introduction chapter: Deng \emph{el al.}~\cite{deng2012digital} argues that neighbouring MVs often have the same motion vectors, making it easy to spot an abnormal motion vector, and Xu \emph{et al.}~\cite{xu2013video} proposed to build a set of vector algebra constraints between MVs across several frames for this purpose.
\end{itemize}

\subsection*{Closing remarks}

It has been a fascinating opportunity to explore niche fields of steganography and steganalysis, investigate and compare their research advances and apply explored methods to video coding. The project has achieved its goals, contributing both theoretically and practically, as a review of LSB steganography adapted to motion vectors and as a collection of practical stego tools.

\cleardoublepage
\bibliographystyle{unsrt}
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{refs}

\appendix
\cleardoublepage
\addcontentsline{toc}{chapter}{Appendix A:\quad Project proposal}
\chapter*{Appendix A: Project proposal}

\includepdf[pages={-}]{proposal.pdf}


\end{document}